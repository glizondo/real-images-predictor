# pip install -r requirements.txt

import logging
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters, CallbackContext, CallbackQueryHandler
import tensorflow as tf
from pathlib import Path
import numpy as np
import os
import credentials.credentials

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)
bot_token = credentials.credentials.bot_token
bot_username = credentials.credentials.bot_username


async def check_origin_photo(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("Processing...")
    await download_photo_sent(update, context)


async def handle_answer_prediction(update: Update, context: CallbackContext, image_likelihood):
    print("Prediction ran")
    percent_likelihood = image_likelihood * 100
    if image_likelihood > 0.5:
        print("Your image has " + str(round(percent_likelihood, 2)) + "% chance of being REAL")
        await update.message.reply_text(
            "Your image has " + str(round(percent_likelihood, 2)) + "% chance of being REAL")
    else:
        print("Your image is generated by Skynet, Run while you can Sarah Connor")
        await update.message.reply_text("Your image is generated by Skynet, Run while you can Sarah Connor")
    keyboard = [[InlineKeyboardButton(text='Yes', callback_data='yes')],
                [InlineKeyboardButton(text='No', callback_data='no')]]
    markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Was the image real?", reply_markup=markup)
    await handle_response_query_user(update, context)


async def handle_response_query_user(update: Update, context: CallbackContext):
    query_real = update.callback_query
    await query_real.answer()
    if query_real.data == 'yes':
        real_photos_train_location = 'algorithm/ai-photos/train/REAL'
        number_image = len(os.listdir(real_photos_train_location)) + 1
        name_image = 'algorithm/ai-photos/use/image.jpg'
        new_name_image = real_photos_train_location + "/image (" + str(number_image) + ").jpg"
        os.rename(name_image, new_name_image)
        await query_real.edit_message_text("Thank you for the feedback")
        print("Query completed")
    if query_real.data == 'no':
        fake_photos_train_location = 'algorithm/ai-photos/train/FAKE'
        number_image = len(os.listdir(fake_photos_train_location)) + 1
        name_image = 'algorithm/ai-photos/use/image.jpg'
        new_name_image = fake_photos_train_location + "/image (" + str(number_image) + ").jpg"
        os.rename(name_image, new_name_image)
        await query_real.edit_message_text("Thank you for the feedback")
        print("Query completed")


async def download_photo_sent(update: Update, context: CallbackContext):
    photo_id = update.message.photo[-1].file_id
    photo = await context.bot.get_file(photo_id)
    print(f'Photo: {photo}')
    print(f'Photo ID: {photo_id}')
    file_path = Path(str(r"algorithm/ai-photos/use/image.jpg"))
    await photo.download_to_drive(custom_path=file_path)
    await update.message.reply_text("Image received")
    await analyze_image_authenticity(update, context)


async def analyze_image_authenticity(update: Update, context: ContextTypes.DEFAULT_TYPE):
    model = tf.keras.models.load_model('./algorithm/model24.h5')
    for f in sorted(Path(r".\algorithm\ai-photos\use").glob("*.jpg")):
        print("Gets to use folder")
        image_to_test = tf.keras.preprocessing.image.load_img(str(f), target_size=(32, 32))
        image_to_test = tf.keras.preprocessing.image.img_to_array(image_to_test)
        image_to_test /= 255
        list_of_images = np.expand_dims(image_to_test, axis=0)
        results = model.predict(list_of_images)
        image_likelihood = results[0][0]
        print(image_likelihood)
        await handle_answer_prediction(update, context, image_likelihood)


# COMMANDS
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    print("Start command ran")
    await update.message.reply_html(
        rf"Welcome to the AI images predictor, {user.mention_html()}. I am here to help you find out if your photos are real as my funny humor or they are part of the Matrix")
    await update.message.reply_text("Please, share the image with me so I can help you!")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    print("Help command ran")
    await update.message.reply_text("/start -> Lets user upload an image to check authenticity")


# HANDLERS
def echo_text(update, context):
    text = update.message.text
    username = ''
    try:
        username = update.message.chat.first_name
    except:
        pass
    return 'What do you mean by "' + text + '"? ' + f"Please, check the /help command for hints of what to do next"


async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print(f'Update {update} caused error {context.error}')


async def echo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(echo_text(update, context))


# MAIN
def main() -> None:
    print('Starting bot...')
    app = Application.builder().token(bot_token).build()

    # Commands
    app.add_handler(CommandHandler('start', start_command))
    app.add_handler(CommandHandler('help', help_command))
    app.add_handler(CallbackQueryHandler(handle_response_query_user))

    # Messages
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, echo))
    app.add_handler(MessageHandler(filters.PHOTO, check_origin_photo))

    # Errors
    app.add_error_handler(error)

    print('Polling...')
    app.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == '__main__':
    main()
